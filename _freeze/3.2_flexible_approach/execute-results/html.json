{
  "hash": "6e75c2248294b46d263af9dd7b42d45e",
  "result": {
    "engine": "knitr",
    "markdown": "---\nfrom: markdown+emoji\ncode-annotations: hover\n---\n\n\n\n\n\n# Abordagem flexível\n\nNa seção anterior, nós aprendemos uma 'abordagem rápida' para calcular a acessibilidade diretamente dentro do `{r5r}`. Uma limitação dessa abordagem é que ela se restringe apenas a algumas métricas de acessibilidade predefinidas disponíveis no `{r5r}`. Frequentemente, queremos analisar outros tipos de métricas de acessibilidade e/ou ter mais controle sobre as diferentes etapas da análise.\n\n**Nesta seção, aprenderemos como calcular matrizes de tempo de viagem e usá-las para calcular diferentes tipos de métricas de acessibilidade.** Esta é uma abordagem mais 'flexível' que combina os pacotes `{r5r}` e `{accessibility}`. Usaremos novamente os dados de exemplo da cidade de Porto Alegre, Brasil, que vêm com o pacote `{r5r}`.\n\n<!-- package logos side by side  -->\n<div style=\"text-align: center\">\n<table><tr><td><img src='/images/r5r_logo.png' width=\"180\"></td><td><img src='/images/accessibility_logo.png' width=\"180\"></td></tr></table>\n</div>\n\n\nEsta abordagem flexível para calcular a acessibilidade envolve apenas 3 etapas:\n\n1. Construir uma rede de transporte roteável  \n2. Calcular uma matriz de tempo de viagem  \n3. Calcular a acessibilidade  \n\nAgora vamos começar carregando os pacotes necessários:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# allocating memory to java\noptions(java.parameters = \"-Xmx6G\")\n\nlibrary(r5r)\nlibrary(accessibility)\nlibrary(h3jsr)\nlibrary(dplyr)\nlibrary(mapview)\nlibrary(ggplot2)\n```\n:::\n\n\n\n\n\n## Construindo uma rede de transporte roteável\n\nPrimeiro, construímos a rede de transporte multimodal passando o caminho da nossa pasta com de dados para a função `r5r::build_network()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# path to data directory\ndata_path <- system.file(\"extdata/poa\", package = \"r5r\")\n\n# build network\nr5r_core <- r5r::build_network(data_path, \n                          verbose = FALSE)\n```\n:::\n\n\n\n\n## Calculando uma matriz de tempo de viagem\n\nA segunda etapa é calcular uma matriz de tempo de viagem com estimativas de porta-a-porta de todas as origens para todos os destinos. Para isso, usamos a função `r5r::travel_time_matrix()`.\n\nEssa função recebe como input a rede roteável criada acima, pontos de origem e destino como `data.frames` com colunas `id`, `lon` e `lat`, o modo de transporte e o horário de partida.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# read points data\npoints <- read.csv(file.path(data_path, \"poa_hexgrid.csv\"))\n\n# routing inputs\nmode <- c(\"walk\", \"transit\")\nmax_trip_duration <- 30                                         # <1>\ndeparture_datetime <- as.POSIXct(\"13-05-2019 14:00:00\",\n                                 format = \"%d-%m-%Y %H:%M:%S\")\n\n# calculate travel time matrix\nttm <- r5r::travel_time_matrix(\n  r5r_core = r5r_core,\n  origins = points,\n  destinations = points,\n  mode = mode,\n  departure_datetime = departure_datetime,\n  max_trip_duration = max_trip_duration,\n  progress = TRUE\n  )\n```\n:::\n\n\n\n1. Em minutos\n\n::: {.callout-tip}\n## Dica\nObserve que a função `r5r::travel_time_matrix()` inclui vários parâmetros adicionais que permitem especificar algumas características da viagem, como tempo máximo de caminhada, uma janela de horário de partida, o número máximo de trechos de transporte público permitidos, etc. Para mais informações, consulte a documentação da função chamando `?r5r::travel_time_matrix` no Console no R ou acesse a documentação no [site do {r5r}](https://ipeagit.github.io/r5r/reference/travel_time_matrix.html).\n:::\n\nO output é um `data.frame`, com essa cara abaixo. É uma matriz em formato longo com as colunas `from_id`, `to_id` e uma terceira coluna indicando o tempo de viagem (em minutos) para cada par de origem e destino.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(ttm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           from_id           to_id travel_time_p50\n            <char>          <char>           <int>\n1: 89a901291abffff 89a901291abffff               1\n2: 89a901291abffff 89a90129157ffff              25\n3: 89a901291abffff 89a9012956bffff              29\n4: 89a901291abffff 89a90128257ffff              27\n5: 89a901291abffff 89a90129ed3ffff              29\n6: 89a901291abffff 89a9012913bffff              17\n```\n\n\n:::\n:::\n\n\n\n\n\n::: {.callout-note appearance=\"simple\"}\n## Velocidade de processamento\n\nA função `travel_time_matrix()` utiliza uma extensão do algoritmo de roteamento RAPTOR [@conway2017evidencebased], o que torna o R5 extremamente rápido. Dependendo do número de pares de origem e destino, o `{r5r}` pode calcular matrizes de tempo de viagem entre 6 e 200 vezes mais rápido do que outros programas de roteamento multimodal [@higgins2022calculating].\n:::\n\n\n## Calculating accessibility \n\n<img align=\"right\" src=\"/images/accessibility_logo.png\" alt=\"logo\" width=\"140\"> \n\nDepois de calcular uma matriz de tempo de viagem, podemos combiná-la com dados de uso do solo para calcular a acessibilidade. Para isso, usaremos o pacote `{accessibility}`, que oferece funções rápidas e convenientes para calcular várias medidas de acessibilidade.\n\nO pacote atualmente inclui mais de 7 tipos diferentes de medidas de acessibilidade (veja os detalhes no [site de documentação do pacote](https://ipeagit.github.io/accessibility/reference/cost_to_closest.html)).\n\n- `cost_to_closest()`: Custo mínimo de viagem até as N oportunidades mais próximas\n- `cumulative_cutoff()`: Acesso cumulativo com base em um *limite* de tempo de viagem\n- `cumulative_interval()`: Acesso cumulativo com base em um *intervalo* de tempo de viagem\n- `gravity()`: Medidas de acessibilidade gravitacioinais\n- `floating_catchment_area()`: Área de captação flutuante\n- `spatial_availability()`: Disponibilidade espacial\n- `balancing_cost()`: Medida de acessibilidade de custo de balanceamento\n\nTodas as funções do pacote recebem como input (a) uma matriz de custos pré-calculada - no nosso caso, uma matriz de tempo de viagem, e (b) alguns dados de uso do solo com o número de oportunidades (por exemplo, escolas, empregos) em cada célula da área de estudo. Ambos os dados devem estar organizados no formato `data.frame`. Vimos acima a estrutura da matriz de viagem. O `data.frame` de uso do solo deve estar organizado assim:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# land use data\nhead(points)                # <1>\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               id       lon       lat population schools jobs healthcare\n1 89a901291abffff -51.15825 -30.05385          0       0 1214          0\n2 89a9012a3cfffff -51.21187 -30.10058        159       0    0          0\n3 89a901295b7ffff -51.16521 -30.07544       1008       0    3          1\n4 89a901284a3ffff -51.20535 -30.09005         92       0    0          0\n5 89a9012809bffff -51.19575 -30.07839        577       0    9          0\n6 89a901285cfffff -51.21108 -30.08124       1170       0  427          0\n```\n\n\n:::\n:::\n\n\n\n1. Os dados de uso do solo devem conter uma coluna `id`, referindo-se aos ids listados na matriz de viagem, e o número de oportunidades em cada local.\n\nAgora vamos calcular alguns indicadores de acessibilidade.\n\n\n### Medida de acessibilidade cumulativa\n\n#### Acessibilidade cumulativa baseada em limite de tempo\n\nPara calcular uma medida tradicional de acessibilidade cumulativa, podemos usar a função `accessibility::cumulative_cutoff()`. Junto com a matriz de viagem e os conjuntos de dados de uso do solo, precisamos apenas passar o nome da coluna com os valores de tempo de viagem, o nome da coluna com a contagem de oportunidades e um limite de tempo de viagem.\n\nAqui, calculamos o número de escolas acessíveis em 20 minutos.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# threshold-based cumulative accessibility\naccess_cum_t <- accessibility::cumulative_cutoff(\n  travel_matrix = ttm, \n  land_use_data = points,\n  travel_cost = 'travel_time_p50',\n  opportunity = 'schools',\n  cutoff = 20\n  )\n  \nhead(access_cum_t)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                id schools\n            <char>   <int>\n1: 89a9012124fffff       3\n2: 89a9012126bffff       3\n3: 89a9012127bffff       3\n4: 89a90128003ffff       9\n5: 89a90128007ffff       7\n6: 89a9012800bffff      11\n```\n\n\n:::\n:::\n\n\n\n### Acessibilidade cumulativa baseada em intervalo de tempo\n\nEstudos anteriores mostraram que a escolha *ad hoc* de um único limite de tempo de viagem pode influenciar substancialmente os resultados das medidas tradicionais de acessibilidade cumulativa, introduzindo viés nas avaliações de projetos de transporte e análises de equidade [@pereira2019future]. Para superar esse problema, propusemos uma medida de acessibilidade cumulativa com *intervalo de tempo* [@tomasiello2023time]. Essa nova métrica estima o número médio (ou mediano) de oportunidades que podem ser alcançadas considerando múltiplos limites minuto a minuto dentro de um intervalo de tempo de viagem.\n\nA principal vantagem dessa métrica é que ela mitiga os impactos de escolhas arbitrárias de duração de viagem na análise de acessibilidade, enquanto preserva as vantagens de cálculo e comunicabilidade das medidas cumulativas baseadas em limites.\n\nAqui, calculamos o número médio de escolas que podem ser alcançadas entre 15 e 25 minutos.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# interval-based cumulative accessibility\naccess_cum_i <- accessibility::cumulative_interval(\n  travel_matrix = ttm, \n  land_use_data = points,\n  travel_cost = 'travel_time_p50',\n  opportunity = 'schools',\n  interval = c(15, 25),\n  summary_function = mean\n  )\n  \nhead(access_cum_i)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                id schools\n            <char>   <int>\n1: 89a9012124fffff       4\n2: 89a9012126bffff       4\n3: 89a9012127bffff       4\n4: 89a90128003ffff       8\n5: 89a90128007ffff      10\n6: 89a9012800bffff      10\n```\n\n\n:::\n:::\n\n\n\n\n\n<!-- \n::: {.callout-tip}\n## Acessibilidade Ativa vs Passiva\n\nPor padrão, a maioria das funções do `{accessibility}` calcula a acessibilidade *ativa*, ou seja, uma contagem ponderada de oportunidades que podem ser alcançadas ao *sair* de um determinado local. Ao definir o parâmetro `active = FALSE`, você pode calcular a área de captação (também conhecida como acessibilidade passiva) de um determinado local, ou seja, o número de pessoas que poderiam *chegar*...\n:::\n -->\n\n\n\n### Medidas de acessibilidade baseadas em gravidade\n\nO pacote também inclui a função `accessibility::gravity()` para calcular métricas de acessibilidade baseadas em gravidade de forma muito flexível.\n\nEla possui um parâmetro `decay_function` que pode receber qualquer *função* para converter o custo de viagem em um fator de impedância usado para ponderar as oportunidades. Para conveniência, o pacote atualmente inclui as seguintes funções:\n\n- `decay_binary()`\n- `decay_exponential()`\n- `decay_linear()`\n- `decay_logistic()`\n- `decay_power()`\n- `decay_stepped()`\n\nVamos ver alguns exemplos com as funções de decaimento logístico e exponencial negativo:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# logistic decay\naccess_lgst <- gravity(\n  travel_matrix = ttm,\n  land_use_data = points,\n  decay_function = decay_logistic(cutoff = 15, sd = 5),\n  opportunity = \"schools\",\n  travel_cost = \"travel_time_p50\"\n)\n\n# negative exponential decay\naccess_nexp <- gravity(\n  travel_matrix = ttm,\n  land_use_data = points,\n  decay_function = decay_exponential(decay_value = 0.1),\n  opportunity = \"schools\",\n  travel_cost = \"travel_time_p50\"\n)\n```\n:::\n\n\n\n\nAqui está uma rápida visualização da forma das curvas de decaimento que utilizamos.\n\n\n\n\n::: {.cell code-show='false'}\n\n```{.r .cell-code  code-fold=\"true\"}\nnegative_exp <- decay_exponential(decay_value = 0.1)\nlogistic <- decay_logistic(cutoff = 15, sd = 5)\n\ntravel_costs <- seq(0, 30, 0.1)\n\nweights <- data.frame(\n  minutes = travel_costs,\n  negative_exp = negative_exp(travel_costs)[[\"0.1\"]],\n  logistic = logistic(travel_costs)[[\"c15;sd5\"]]\n)\n\n# reshape data to long format\nweights <- tidyr::pivot_longer(\n  weights,\n  cols = c('negative_exp',  'logistic'),\n  names_to = \"decay_function\",\n  values_to = \"weights\"\n)\n\nggplot(weights) +\n  geom_line(aes(minutes, weights, color = decay_function),\n            show.legend = FALSE) +\n  facet_wrap(. ~ decay_function, ncol = 2) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](3.2_flexible_approach_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\n\n## Mapa de Acessibilidade\n\nAgora é muito simples unir todas essas estimativas de acessibilidade à nossa grade espacial para visualizar esses resultados em um mapa.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# rbind all accessibility results in a single data.frame\naccess_cum_t$metric <- 'cum_threshold'\naccess_cum_i$metric <- 'cum_interval'\naccess_lgst$metric <- 'grav_logistic'\naccess_nexp$metric <- 'grav_exponential'\n\ndf <- rbind(access_cum_t,\n            access_cum_i,\n            access_lgst,\n            access_nexp\n            )\n\n# retrieve polygons of H3 spatial grid\ngrid <- h3jsr::cell_to_polygon(\n  points$id, \n  simple = FALSE\n  )\n\n# merge accessibility estimates\naccess_sf <- left_join(\n  grid, \n  df, \n  by = c('h3_address'='id')\n  )\n```\n:::\n\n\n\n\n\nGerar mapa com visualização espacial dos resultados\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = access_sf, aes(fill = schools), color= NA) +\n  scale_fill_viridis_c(direction = -1, option = 'B') +\n  labs(title = \"Acesso a escolas por transporte público usando diferentes métricas de acessibilidade\", fill = \"Índice de\\nacessibilidade\") +\n  theme_minimal() +\n  theme(axis.title = element_blank()) +\n  facet_wrap(~metric) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](3.2_flexible_approach_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n::: {.callout-tip appearance=\"simple\"}\nO pacote `{r5r}` possui várias funcionalidades avançadas:\n\n- Consideração de custos monetários\n- Consideração Nível de tolerância ao Estresse do Tráfego (LTS)\n- Uso de uma janela de partida em vez de um horário exato\n- Planejamento de viagens com output detalhado\n- Cálculo de isócronas\n- Geração de outputs que não cabem na memória RAM\n\nConsulte as [vignettes do pacote no site para mais informações](https://ipeagit.github.io/r5r/index.html).\n:::",
    "supporting": [
      "3.2_flexible_approach_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}